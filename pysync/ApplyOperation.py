import concurrent.futures as cf

from pysync.Functions import match_attr
from pysync.Timer import logtime
from pysync.Options_parser import load_options


@logtime
def run_drive_ops(diff_infos, all_data, drive):
    """Run drive_op for each push/pull operation using many threads

    Will not exceed the `Max upload threads` option at any given time

    Applies the changes to folders first, then files with least depth

    Args:
        diff_infos (list): list generated by get_diff, containing FileInfo objects
        all_data (dict): dict from get_diff
        drive (googleapiclient.discovery.Resource): Resource object from service.files() in init_drive
    """

    pending = match_attr(diff_infos, action="push") + \
        match_attr(diff_infos, action="pull")
    if pending:
        print(f"Applying {str(len(pending))} changes..")
    else:
        print("No available changes")

    # * Ideally this would also use concurrent.future but
    max_threads = load_options("MAX_UPLOAD")
    # max_threads = 1
    # * must be processpool, threadpool runs into memory issue with python
    with cf.ProcessPoolExecutor(max_workers=max_threads) as executor:
        while pending:
            pending.sort(key=lambda x: (  # * folders first, then less depth first
                not x.isfolder, len(x.path.split("/"))), reverse=True)
            # * going from the back cos i'm removing it 1 by 1, thats why its reversed
            # * sorta like a queue?

            index = len(pending) - 1
            for _ in range(len(pending)):

                info = pending[index]
                ret_code = info.check_ready(all_data)
                if ret_code == "ready":
                    if load_options("PRINT_UPLOAD"):
                        print(len(pending), info.action + "ing", info.change_type, info.path)

                    future = executor.submit(info.drive_op, all_data[info.parent_path], drive)

                    def add_all_data(fut):

                        result = fut.result()
                        if isinstance(result, str):
                            del all_data[result]
                        else:
                            all_data[result.path] = result

                    future.add_done_callback(add_all_data)
                    pending.remove(info)

                elif ret_code == "ignored":
                    pending.remove(info)

                elif ret_code == "not ready":
                    pass

                index -= 1
            # * after each iteration, the leftovers are sorted and ran again

    print("All done")
