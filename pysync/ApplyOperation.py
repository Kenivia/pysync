import time
from threading import (
    Thread,
    active_count,
)

from pysync.Functions import match_attr
from pysync.Timer import logtime
from pysync.Options_parser import load_options


@logtime
def run_drive_ops(diff_infos, all_data, drive):
    """Run drive_op for each push/pull operation using many threads

    Will not exceed MAX_UPLOAD_THREADS at any given time

    Applies the changes to folders first, then files with least depth

    Args:
        diff_infos (list): list generated by get_diff, containing FileInfo objects
        all_data (dict): dict from get_diff
        drive (pydrive2.drive.GoogleDrive): drive object from init_drive
    """

    intial_thread_count = active_count()
    all_threads = []
    infos = match_attr(diff_infos, action="push") + \
        match_attr(diff_infos, action="pull")
    if infos:
        print("Applying {} changes..".format(str(len(infos))))
    else:
        print("No available changes")

    # * Ideally this would also use concurrent.future but
    while infos:
        infos.sort(key=lambda x: (  # * folders first, then less depth first
            not x.isfolder, len(x.path.split("/"))), reverse=True)
        # * I go from the back cos i'm removing it 1 by 1, thats why its reversed
        # * sorta like a queue?

        index = len(infos) - 1
        for _ in range(len(infos)):
            if active_count() - intial_thread_count >= load_options("MAX_UPLOAD"):
                time.sleep(load_options("RECHECK_TIME"))
                break

            item = infos[index]
            ret_code = item.check_ready(all_data)
            if ret_code == "ready":
                if load_options("PRINT_UPLOAD"):
                    print(len(infos), item.action + "ing", item.change_type, item.path)
                t = Thread(target=item.drive_op, args=(all_data, drive))
                t.start()
                all_threads.append(t)
                infos.remove(item)

            elif ret_code == "ignored":
                infos.remove(item)

            elif ret_code == "not ready":
                pass
            index -= 1
            # * after each iteration, the leftovers are sorted and ran again

    [i.join() for i in all_threads]
    print("All done")
